# Alumno 4

## Oracle

### Ejercicio 1

> Crear un tablespace de `UNDO`

```sql
CREATE UNDO TABLESPACE UNDO
DATAFILE 'undo.dbf' SIZE 500M
AUTOEXTEND ON;

Tablespace created.
```

> Intentar crear una tabla en él

```sql
CREATE TABLE undo_table_test(
    id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    first_name VARCHAR2(50) NOT NULL,
    PRIMARY KEY(id)
)
TABLESPACE UNDO;
CREATE TABLE undo_table_test(
*
ERROR at line 1:
ORA-30022: Cannot create segments in undo tablespace
```

No se pueden crear tablas manualmente en tablespaces de UNDO, ya que se usan exclusivamente para rollback, y esto es algo que maneja automáticamente Oracle.

### Ejercicio 2

> Crear un tablespace temporal llamado `TEMP2`

```sql
CREATE TEMPORARY TABLESPACE TEMP2 TEMPFILE 'temporary2.dbf' SIZE 5M;

Tablespace created.
```

> Escribir un `SELECT` que genere un script que haga usar `TEMP2` a todos los usuarios que tienen `USERS` como tablespace por defecto

```sql
SELECT 'ALTER USER ' || USERNAME || ' TEMPORARY TABLESPACE TEMP2;' AS Script
FROM DBA_USERS
WHERE DEFAULT_TABLESPACE = 'USERS';
```

```sql
SCRIPT
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
ALTER USER GSMCATUSER TEMPORARY TABLESPACE TEMP2;
ALTER USER MDDATA TEMPORARY TABLESPACE TEMP2;
ALTER USER BECARIO TEMPORARY TABLESPACE TEMP2;
ALTER USER SYSBACKUP TEMPORARY TABLESPACE TEMP2;
ALTER USER REMOTE_SCHEDULER_AGENT TEMPORARY TABLESPACE TEMP2;
ALTER USER USRPRACTICA1 TEMPORARY TABLESPACE TEMP2;
ALTER USER GSMUSER TEMPORARY TABLESPACE TEMP2;
ALTER USER SYSRAC TEMPORARY TABLESPACE TEMP2;
ALTER USER GSMROOTUSER TEMPORARY TABLESPACE TEMP2;
ALTER USER SI_INFORMTN_SCHEMA TEMPORARY TABLESPACE TEMP2;
ALTER USER AUDSYS TEMPORARY TABLESPACE TEMP2;
ALTER USER EXAMENBD34 TEMPORARY TABLESPACE TEMP2;
ALTER USER DIP TEMPORARY TABLESPACE TEMP2;
ALTER USER ORDPLUGINS TEMPORARY TABLESPACE TEMP2;
ALTER USER TESTING TEMPORARY TABLESPACE TEMP2;
ALTER USER SYSKM TEMPORARY TABLESPACE TEMP2;
ALTER USER ORDDATA TEMPORARY TABLESPACE TEMP2;
ALTER USER ORACLE_OCM TEMPORARY TABLESPACE TEMP2;
ALTER USER SCOTT TEMPORARY TABLESPACE TEMP2;
ALTER USER HIPODROMO TEMPORARY TABLESPACE TEMP2;
ALTER USER SYSDG TEMPORARY TABLESPACE TEMP2;
ALTER USER ORDSYS TEMPORARY TABLESPACE TEMP2;
```

### Ejercicio 3

> Borrar todos los tablespaces creados sin que quede rastro de ellos. Realizar las acciones previas que sean necesarias

```sql
DROP TABLESPACE UNDO INCLUDING CONTENTS AND DATAFILES;

Tablespace dropped.

DROP TABLESPACE TEMP2 INCLUDING CONTENTS AND DATAFILES;

Tablespace dropped.
```

### Ejercicio 4

> Averiguar los segmentos existentes para realizar un ROLLBACK y el tamaño de sus extents

```sql
SELECT r.segment_name,r.tablespace_name,r.status,e.extent_id,e.bytes
FROM DBA_ROLLBACK_SEGS r
INNER JOIN DBA_EXTENTS e
ON r.segment_name = e.segment_name;
```

El output es largo, así que sólo muestro un fragmento:

![rollbacksegs](https://i.imgur.com/si0eivY.png)

En el recuadro marco un segmento de ejemplo, con todos sus extents y respectivos tamaños.

Cada registro es un extent dentro de dicho segmento, y esto queda claro al ver la numeración de los extents consecutivos.

### Ejercicio 5

> Hacer un procedimiento llamado `MostrarUsuariosAccesoTS` que liste usuarios que tienen permisos de lectura (select) o escritura (insert,update,delete) a cualquiera de los objetos almacenados en el tablespace indicado

```sql
CREATE OR REPLACE PROCEDURE comprobar_privilegios(
  p_usuario IN DBA_USERS.username%TYPE,
  p_tablespace IN DBA_TABLES.tablespace_name%TYPE,
  p_control OUT BOOLEAN
) AS

    CURSOR c_lista_privilegios IS
        SELECT *
        FROM DBA_TAB_PRIVS
        WHERE grantee = p_usuario
            OR grantee IN (
                SELECT granted_role
                FROM DBA_ROLE_PRIVS
                CONNECT BY PRIOR granted_role = grantee START WITH grantee = p_usuario
            )
        ORDER BY 1,2,3,4;

    vn_contador NUMBER := 0;
    vn_objeto_en_tablespace NUMBER;

BEGIN

    FOR i IN c_lista_privilegios LOOP

        IF i.privilege IN ('SELECT','INSERT','UPDATE','DELETE') THEN

            SELECT COUNT(*) INTO vn_objeto_en_tablespace
            FROM DBA_TABLES
            WHERE owner = i.owner
              AND table_name = i.table_name
              AND tablespace_name = p_tablespace;
            
            IF vn_objeto_en_tablespace = 1 THEN
                vn_contador := vn_contador + 1;
                vn_objeto_en_tablespace := 0;
            END IF;

        END IF;
  
    END LOOP;

    IF vn_contador > 0 THEN
        p_control := TRUE;
    ELSE
        p_control := FALSE;
    END IF;

END;
/
-- (1)!
```

1. Este es el procedimiento hijo, aquí se comprueban los privilegios del usuario, y se comprueba si los objetos sobre los que tiene privilegios están en el tablespace que se busca

```sql
CREATE OR REPLACE PROCEDURE MostrarUsuariosAccesoTS(
  p_nombre_tablespace IN VARCHAR2
) AS

    CURSOR c_usuarios IS
        SELECT username
        FROM DBA_USERS;

    vb_control BOOLEAN;

BEGIN

  FOR i IN c_usuarios LOOP

    comprobar_privilegios(i.username,p_nombre_tablespace,vb_control);

    IF vb_control THEN
      DBMS_OUTPUT.PUT_LINE('El usuario ' || i.username || ' tiene acceso en el tablespace ' || p_nombre_tablespace);
    END IF;
    
  END LOOP;

END;
/
-- (1)!
```

1. Este es el procedimmiento padre, y aquí es donde sucede el loop de usuarios. Se mandan ciertos parámetros al hijo para comprobar si tiene alguno de los privilegios que se buscan sobre objetos en el tablespace indicado.

```sql
EXEC MostrarUsuariosAccesoTS('USERS');

El usuario SYS tiene acceso en el tablespace USERS
El usuario EXAMENBD34 tiene acceso en el tablespace USERS
El usuario HIPODROMO tiene acceso en el tablespace USERS
El usuario ORDSYS tiene acceso en el tablespace USERS
El usuario USRPRACTICA1 tiene acceso en el tablespace USERS

PL/SQL procedure successfully completed.
```

Para comprobar que los resultados son correctos, puedo tomar de prueba al usuario `HIPODROMO`.

Siguiendo la lógica de estos procedimientos, puedo por ejemplo primero mostrar el listado completo de privilegios que tiene `HIPODROMO`:

```sql
SELECT grantee,owner,table_name,privilege
FROM DBA_TAB_PRIVS
WHERE grantee = 'HIPODROMO'
    OR grantee IN (
        SELECT granted_role
        FROM DBA_ROLE_PRIVS
        CONNECT BY PRIOR granted_role = grantee START WITH grantee = 'HIPODROMO'
    )
ORDER BY 1,2,3,4;
```

```sql
GRANTEE 								                                                                                                                 OWNER	  TABLE_NAME								                                                                                                                   PRIVILEGE
-------------------------------------------------------------------------------------------------------------------------------- -------------------------------------------------------------------------------------------------------------------------------- -------------------------------------------------------------------------------------------------------------------------------- ----------------------------------------
HIPODROMO								                                                                                                                 SCOTT	  DEPT								                                                                                                                           DELETE
HIPODROMO								                                                                                                                 SCOTT	  DEPT								                                                                                                                           SELECT
```

Vemos que sobre la tabla `DEPT` de `SCOTT` tiene permisos que buscamos.

Ahora sólo quedaría comprobar si efectivamente esa tabla está en el tablespace `USERS`:

```sql
SELECT owner,table_name,tablespace_name
FROM DBA_TABLES
WHERE owner = 'SCOTT'
  AND table_name = 'DEPT'
  AND tablespace_name = 'USERS';
```

```sql
OWNER								                                                                                                                         TABLE_NAME								                                                                                                                  TABLESPACE_NAME
-------------------------------------------------------------------------------------------------------------------------------- -------------------------------------------------------------------------------------------------------------------------------- ------------------------------
SCOTT								                                                                                                                         DEPT	  USERS
```

Vemos que sí.

Ese usuario por lo tanto queda marcado como que tiene acceso al tablespace `USERS` y se muestra.  
El mismo proceso de comprobaciones se repite para todos los usuarios.

### Ejercicio 6

> Realiza un procedimiento llamado MostrarInfoTabla que reciba el nombre de una tabla y muestre la siguiente información sobre la misma: propietario, usuarios que pueden leer sus datos, usuarios que pueden cambiar (insertar, modificar o eliminar) sus datos, usuarios que pueden modificar su estructura, usuarios que pueden eliminarla, lista de extensiones y en qué fichero de datos se encuentran.

























## PostgreSQL

> Averigua si pueden establecerse claúsulas de almacenamiento para las tablas o los espacios de tablas en Postgres.









## MariaDB

> Averigua si existe el concepto de índice en MySQL y si coincide con el existente en ORACLE. Explica los distintos tipos de índices existentes.








## MongoDB

> Explica los distintos motores de almacenamiento que ofrece MongoDB, sus características principales y en qué casos es más recomendable utilizar cada uno de ellos.








